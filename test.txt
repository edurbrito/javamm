MonteCarloPi  {

	.construct MonteCarloPi().V {

		invokespecial(this, "<init>").V;

		}

	.method public performSingleEstimate().bool {

		ti1.i32 :=.i32 0.i32 -.i32 100.i32;

		ti3.i32 :=.i32 invokestatic(MathUtils, "random", ti2.i32, 100.i32).V;

		rand1.i32 :=.i32 ti3.i32;

		ti5.i32 :=.i32 0.i32 -.i32 100.i32;

		ti7.i32 :=.i32 invokestatic(MathUtils, "random", ti6.i32, 100.i32).V;

		rand2.i32 :=.i32 ti7.i32;

		ti8.i32 :=.i32 rand1.i32 *.i32 rand1.i32;

		ui9.i32 :=.i32 rand2.i32 *.i32 rand2.i32;

		ti10.i32 :=.i32 ti8.i32 +.i32 ui9.i32;

		squareDist.i32 :=.i32 ti10.i32 /.i32 100.i32;

		if ( squareDist.i32 <.i32 100.i32 ) goto bodyIf0;

		in_circle.bool :=.bool 0.bool;

		goto endif0;

		bodyIf0: 

		in_circle.bool :=.bool 1.bool;

		endif0:

		tb11.bool :=.bool in_circle.bool;

		ret.bool tb11.bool;

		}

	.method public estimatePi100(n.i32).i32 {

		samples_so_far.i32 :=.i32 0.i32;

		samples_in_circle.i32 :=.i32 0.i32;

		Loop1:

		if ( samples_so_far.i32 <.i32 $1.n.i32) goto Body1;

		goto EndLoop1;

		Body1:

		tb0.bool :=.bool  invokevirtual(this,"performSingleEstimate").bool;

		if ( tb0.bool &&.bool 1.bool ) goto bodyIf1;

		goto endif1;

		bodyIf1: 

		samples_in_circle.i32 :=.i32 samples_in_circle.i32 +.i32 1.i32;

		endif1:

		samples_so_far.i32 :=.i32 samples_so_far.i32 +.i32 1.i32;

		goto Loop1;

		EndLoop1:

		ti1.i32 :=.i32 400.i32 *.i32 samples_in_circle.i32;

		pi_estimate.i32 :=.i32 ti1.i32 /.i32 $1.n.i32;

		ti2.i32 :=.i32 pi_estimate.i32;

		ret.i32 ti2.i32;

		}

	.method public static main(args.array.String).V {

		ti1.i32 :=.i32 invokestatic(ioPlus, "requestNumber").V;

		num_samples.i32 :=.i32 ti1.i32;

		ti3.MonteCarloPi :=.MonteCarloPi new (MonteCarloPi).MonteCarloPi;

		invokespecial(ti3.MonteCarloPi.MonteCarloPi,"<init>").V

		ti4.i32 :=.i32 ti3.MonteCarloPi;

		pi_estimate_times_100.i32 :=.i32 ti4.i32;

		invokestatic(ioPlus, "printResult", pi_estimate_times_100.i32).V;

		ret.V;

		}

	}

