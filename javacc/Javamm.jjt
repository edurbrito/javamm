options
{
    LOOKAHEAD=1;
    DEBUG_PARSER = true;
}

PARSER_BEGIN(Javamm)


public class Javamm
{
    private static final int MAX_ERRORS = 10;
    private int nErrors = 0;

    private void while_err_handling(ParseException pe){
        this.nErrors++;

        if( this.nErrors > MAX_ERRORS){
            throw new RuntimeException("Limit of" + MAX_ERRORS + " errors reached!");
        }

        System.out.println(pe.toString());
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != RPRTHSIS);

    }
};

PARSER_END(Javamm)

// Ignorable Symbols
SKIP :
{
    " "
    | "\t"
    | "\r"
    | "\n"
    | < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>             // inline comments
    | < "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/" >       // block comments
}

// Reserved Words

TOKEN :
{
    <BOOLEAN: "boolean">
    | <CLASS: "class" >
    | <ELSE: "else">
    | <EXTENDS: "extends">
    | <FALSE_: "false">
    | <IF: "if">
    | <IMPORT: "import">
    | <INT: "int">
    | <LENGTH: "length">
    | <MAIN: "main">
    | <NEW: "new">
    | <PUBLIC: "public">
    | <RETURN: "return">
    | <STATIC: "static">
    | <STRING: "String">
    | <THIS: "this">
    | <TRUE_: "true">
    | <VOID: "void">
    | <WHILE: "while">
}

// Operations

TOKEN :
{
    < AND : "&&">
    | < DIV : "/">
    | < EQUAL : "=">
    | < LESSTHAN : "<">
    | < MULT : "*">
    | < NOT : "!">
    | < SUB : "-">
    | < SUM : "+">
}

// Delimiters

TOKEN :
{
    < DOT: "." >
    | < COMMA: "," >
    | < SEMICOLON: ";" >
    | < LBRACKET: "{" >
    | < RBRACKET: "}" >
    | < LSQBRACKET: "[" >
    | < RSQBRACKET: "]" >
    | < LPRTHSIS: "(">
    | < RPRTHSIS: ")">
}

// Identifiers

TOKEN: {
    < INTEGER: (["0"-"9"])+ >
    | < IDENTIFIER: ["A"-"Z", "a"-"z", "_", "$"](["0"-"9", "A"-"Z", "a" - "z", "_", "$"])* >
}


// {..} means (..)* and [..] means (..)?

SimpleNode Parse(): {}
{
   (ImportDeclaration())* ClassDeclaration() <EOF> // Java code inside brackets
   {return jjtThis;}
}

void ImportDeclaration(): {}
{
    <IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>
}

void ClassDeclaration(): {}
{
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)?
       ClassBody()
}

void ClassBody() : {}
{
    <LBRACKET>
        (VarDeclaration())*
        (MethodDeclaration())*
    <RBRACKET>
}

void VarDeclaration(): {}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration(): {}
{
    <PUBLIC> (MainMethodDeclaration() | RegularMethodDeclaration())
}

void MainMethodDeclaration(): {}
{
       <STATIC> <VOID> <MAIN> <LPRTHSIS> <STRING> <LSQBRACKET> <RSQBRACKET> <IDENTIFIER> <RPRTHSIS>
       <LBRACKET>
             MethodBody()
       <RBRACKET>
}

void RegularMethodDeclaration():{}
{
        Type() <IDENTIFIER> <LPRTHSIS> ( MethodArguments() )? <RPRTHSIS>
        <LBRACKET>
            MethodBody()
            ReturnExpression()
        <RBRACKET>
}

void MethodBody(): {}
{
        ( LOOKAHEAD(2) VarDeclaration())*
        (Statement())*
}

void ReturnExpression(): {}
{
        <RETURN> Expression() <SEMICOLON>
}

void MethodArguments(): {}
{
        Argument() ( <COMMA> Argument() )*
}

void Argument(): {}
{
        Type() <IDENTIFIER>
}

void Type(): {}
{
        <INT> (<LSQBRACKET> <RSQBRACKET>)?
        |
        <BOOLEAN>
        |
        <IDENTIFIER>
}

void Statement(): {}
{
         <LBRACKET> (Statement())* <RBRACKET>
         | IfStatement()
         | WhileStatement()
         | (LOOKAHEAD(2) EqualStatement() | Expression()) <SEMICOLON>
}

void IfStatement(): {}
{
        <IF> <LPRTHSIS> Expression() <RPRTHSIS> Statement() <ELSE> Statement() // else shouldn't be optional???
}

void WhileStatement(): {}
{
        <WHILE> <LPRTHSIS>
         try {
            Expression() <RPRTHSIS>
         } catch(ParseException e) {
              while_err_handling(e);
         }

        Statement()
}

void EqualStatement(): {}
{
        <IDENTIFIER> ( AccessToArray() )? <EQUAL> Expression()
}

void Expression(): {} {
        AndExpression()
}

 void AndExpression() : {}
 {
        LessThanExpression() ( <AND> LessThanExpression())*
 }

 void LessThanExpression(): {}
 {
        AdditiveExpression() ( <LESSTHAN> AdditiveExpression())*
 }

 void AdditiveExpression(): {}
{
        MultiplicativeExpression() ( ( <SUM> | <SUB> ) MultiplicativeExpression() )*
}

void MultiplicativeExpression(): {}
{
        PrimaryExpression() ( ( <MULT> | <DIV> ) PrimaryExpression() )*
}

void PrimaryExpression(): {}
{
        PrimaryPrefix() (PrimarySuffix())?
}

void PrimaryPrefix(): {}
{
        Literal()
        | AllocationExpression()
        | <NOT> Expression()
        | <LPRTHSIS> Expression() <RPRTHSIS>
}

void PrimarySuffix(): {}
{
    AccessToArray()
    | DotExpression()
}

void Literal(): {}
{
         <INTEGER>
         | <TRUE_>
         | <FALSE_>
         | <IDENTIFIER>
         | <THIS>
}

void AllocationExpression(): {}
{
        <NEW> (<INT> AccessToArray() | <IDENTIFIER> <LPRTHSIS> <RPRTHSIS> )
}

void DotExpression(): {}
{
        <DOT>
        (
            <LENGTH>
            | <IDENTIFIER> <LPRTHSIS> (Expression() (<COMMA> Expression())*)? <RPRTHSIS>
        )
}

void AccessToArray(): {}
{
        <LSQBRACKET> Expression() <RSQBRACKET>
}