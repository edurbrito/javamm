options
{
    LOOKAHEAD=1;
    DEBUG_PARSER = true;
}

PARSER_BEGIN(Javamm)


public class Javamm
{
    private static final int MAX_ERRORS = 10;
    private int nErrors = 0;

    private void while_err_handling(ParseException pe){
        this.nErrors++;

        if( this.nErrors > MAX_ERRORS){
            throw new RuntimeException("Limit of" + MAX_ERRORS + " errors reached!");
        }

        System.out.println(pe.toString());
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != RPRTHSIS);

    }
};

PARSER_END(Javamm)

// Ignorable Symbols
SKIP :
{
    " "
    | "\t"
    | "\r"
    | "\n"
    | < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>             // inline comments
    | < "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/" >       // block comments
}

// Reserved Words

TOKEN :
{
    <BOOLEAN: "boolean">
    | <CLASS: "class" >
    | <ELSE: "else">
    | <EXTENDS: "extends">
    | <FALSE_: "false">
    | <IF: "if">
    | <IMPORT: "import">
    | <INT: "int">
    | <LENGTH: "length">
    | <MAIN: "main">
    | <NEW: "new">
    | <PUBLIC: "public">
    | <RETURN: "return">
    | <STATIC: "static">
    | <STRING: "String">
    | <THIS: "this">
    | <TRUE_: "true">
    | <VOID: "void">
    | <WHILE: "while">
}

// Operations

TOKEN :
{
    < AND : "&&">
    | < DIV : "/">
    | < EQUAL : "=">
    | < LESSTHAN : "<">
    | < MULT : "*">
    | < NOT : "!">
    | < SUB : "-">
    | < SUM : "+">
}

// Delimiters

TOKEN :
{
    < DOT: "." >
    | < COMMA: "," >
    | < SEMICOLON: ";" >
    | < LBRACKET: "{" >
    | < RBRACKET: "}" >
    | < LSQBRACKET: "[" >
    | < RSQBRACKET: "]" >
    | < LPRTHSIS: "(">
    | < RPRTHSIS: ")">
}

// Identifiers

TOKEN: {
    < INTEGER: (["0"-"9"])+ >
    | < IDENTIFIER: ["A"-"Z", "a"-"z", "_", "$"](["0"-"9", "A"-"Z", "a" - "z", "_", "$"])* >
}


// {..} means (..)* and [..] means (..)?

SimpleNode Parse() #Program : {}
{
   (ImportDeclaration())* ClassDeclaration() <EOF> // Java code inside brackets
   {return jjtThis;}
}

void ImportDeclaration() #Import : {}
{
    <IMPORT> (<IDENTIFIER> (<DOT> <IDENTIFIER>)*) #Library  <SEMICOLON>
}

void ClassDeclaration() #Class : {Token classToken;}
{
    <CLASS> classToken=<IDENTIFIER> {jjtThis.put("className", classToken.image);} (<EXTENDS> classToken=<IDENTIFIER> {jjtThis.put("classExtended", classToken.image);})?
       ClassBody()
}

void ClassBody() #void : {}
{
    <LBRACKET>
        (VarDeclaration())*
        (MethodDeclaration())*
    <RBRACKET>
}

void VarDeclaration() #Var: {}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration() #void : {}
{
    <PUBLIC> (MainMethodDeclaration() | RegularMethodDeclaration())
}

void MainMethodDeclaration() #MainMethod : {}
{
       <STATIC> <VOID> <MAIN> <LPRTHSIS> <STRING> <LSQBRACKET> <RSQBRACKET> <IDENTIFIER> <RPRTHSIS>
       <LBRACKET>
             MethodBody()
       <RBRACKET>
}

void RegularMethodDeclaration() #RegularMethod :{}
{
        Type() <IDENTIFIER> <LPRTHSIS> ( MethodArguments() )? <RPRTHSIS>
        <LBRACKET>
            MethodBody()
            ReturnExpression()
        <RBRACKET>
}

void MethodBody() #void : {}
{
        ( LOOKAHEAD(2) VarDeclaration())*
        (Statement())*
}

void ReturnExpression() #Return : {}
{
        <RETURN> Expression() <SEMICOLON>
}

void MethodArguments(): {}
{
        Argument() ( <COMMA> Argument() )*
}

void Argument(): {}
{
        Type() <IDENTIFIER> #Identifier
}

void Type(): {}
{
        (<INT> (ArrayType())?) #Integer
        |
        <BOOLEAN> #Boolean
        |
        <IDENTIFIER> #Identifier
}

void ArrayType() #Array : {}
{
    <LSQBRACKET> <RSQBRACKET>
}

void Statement() #void : {}
{
         <LBRACKET> (Statement())* <RBRACKET>
         | IfStatement()
         | WhileStatement()
         | (LOOKAHEAD(2) EqualStatement() | Expression()) <SEMICOLON>
}

void IfStatement() #void: {}
{
        (<IF> <LPRTHSIS> (Expression()) #IfCondition <RPRTHSIS> (Statement()) #IfBody <ELSE> (Statement()) #ElseBody ) #IfElse(3)
}

void WhileStatement() #void : {}
{
        (<WHILE> <LPRTHSIS>
         try {
            (Expression()) #WhileCondition <RPRTHSIS>
         } catch(ParseException e) {
              while_err_handling(e);
         }

        (Statement()) #WhileBody ) #While(2)
}

void EqualStatement() #void : {}
{
        (<IDENTIFIER> ( AccessToArray() )?) #Identifier <EQUAL> Expression() #EqualStatement(2)
}

void Expression() #void : {} {
        AndExpression()
}

 void AndExpression() #void : {}
 {
        LessThanExpression() ( <AND> LessThanExpression() #And(2) )*
 }

 void LessThanExpression() #void : {}
 {
        AdditiveExpression() ( <LESSTHAN> AdditiveExpression() #LessThan(2))*
 }

 void AdditiveExpression() #void : {}
{
        MultiplicativeExpression() ( ( <SUM> MultiplicativeExpression() #Sum(2) | <SUB> MultiplicativeExpression() #Sub(2)) )*
}

void MultiplicativeExpression() #void : {}
{
        PrimaryExpression() ( ( <MULT> PrimaryExpression() #Mult(2) | <DIV> PrimaryExpression() #Div(2)))*
}

void PrimaryExpression() #void : {}
{
        PrimaryPrefix() (PrimarySuffix())?
}

void PrimaryPrefix() #void : {}
{
        Literal()
        | AllocationExpression() #New
        | (<NOT> Expression())  #Not
        | <LPRTHSIS> Expression() <RPRTHSIS>
}

void PrimarySuffix() #void : {}
{
    AccessToArray()
    | DotExpression()
}

void Literal() #void : {}
{
         <INTEGER> #Integer
         | <TRUE_> #Boolean
         | <FALSE_> #Boolean
         | <IDENTIFIER> #Identifier
         | <THIS> #This
}

void AllocationExpression() #void : {}
{
        <NEW> (<INT> AccessToArray() | <IDENTIFIER> #Identifier <LPRTHSIS> <RPRTHSIS> )
}

void DotExpression() : {}
{
        <DOT>
        (
            <LENGTH> #Length
            | (<IDENTIFIER> <LPRTHSIS> (Expression() (<COMMA> Expression())*)? <RPRTHSIS>) #Method
        )
}

void AccessToArray(): {}
{
        <LSQBRACKET> Expression() <RSQBRACKET>
}