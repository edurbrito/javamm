Lazysort {
	.construct Lazysort().V {
		invokespecial(this, "<init>").V;
		}
	.method public static main(a.array.String).V {
		L.array.i32 :=.array.i32 new(array, 10.i32).array.i32;
		i.i32 :=.i32 0.i32;
		Loop1:
		ti0.i32 :=.i32 arraylength(L.array.i32).i32;
		ui1.i32 :=.i32 ti0.i32;
		if ( i.i32 <.i32 ui1.i32) goto Body1;
		goto EndLoop1;
		Body1:
		ti2.i32:=.i32 i.i32;ti3.i32 :=.i32 arraylength(L.array.i32).i32;ti4.i32 :=.i32 ti3.i32;L[ti2.i32].i32 :=.array.i32 ti4.i32 -.i32 i.i32;
		i.i32 :=.i32 i.i32 +.i32 1.i32;
		goto Loop1;
		EndLoop1:
		q.Lazysort :=.Lazysort new (Lazysort).Lazysort;
		invokespecial(q.Lazysort,"<init>").Lazysort;
		invokevirtual(q.Lazysort,"quicksort").bool;invokestatic(Quicksort, "printL",L.array.i32).V;
		d.bool :=.bool invokevirtual(q.Lazysort,"printL").bool;
		ret.V;
		}
	.method public quicksort(L.array.i32).bool {
		rand.i32 :=.i32 invokestatic(MathUtils, "random",0.i32,5.i32).i32;
		if ( rand.i32 <.i32 4.i32 ) goto body0;
		lazy.bool :=.bool 0.bool;
		goto endif0;
		body0:
		 invokevirtual(this,"beLazy",$1.L.array.i32).i32;
		lazy.bool :=.bool 1.bool;
		endif0:
		if ( lazy.bool &&.bool true.bool ) goto body1;
		ti7.i32 :=.i32 arraylength($1.L.array.i32).i32;
		ti8.i32 :=.i32 ti7.i32;
		ti9.i32 :=.bool ti8.i32 -.i32 1.i32;
		tb10.bool :=.bool  invokevirtual(this,"quicksort",$1.L.array.i32,0.i32,ti9.i32).i32;
		lazy.bool :=.bool tb10.bool;
		goto endif1;
		body1:
		lazy.bool :=.bool lazy.bool !.bool lazy.bool;
		endif1:
		ret.bool lazy.bool;
		}
	.method public beLazy(L.array.i32).bool {
		ti11.i32 :=.i32 arraylength($1.L.array.i32).i32;
		ti12.i32 :=.i32 ti11.i32;
		_allowedNameL.i32 :=.i32 ti12.i32;
		_allowedNameI.i32 :=.i32 0.i32;
		Loop2:
		ui13.i32 :=.i32 _allowedNameL.i32 /.i32 2.i32;
		if ( _allowedNameI.i32 <.i32 ui13.i32) goto Body2;
		goto EndLoop2;
		Body2:
		ti14.i32:=.i32 _allowedNameI.i32;$1.L[ti14.i32].i32 :=.array.i32 invokestatic(MathUtils, "random",0.i32,10.i32).i32;
		_allowedNameI.i32 :=.i32 _allowedNameI.i32 +.i32 1.i32;
		goto Loop2;
		EndLoop2:
		Loop3:
		if ( _allowedNameI.i32 <.i32 _allowedNameL.i32) goto Body3;
		goto EndLoop3;
		Body3:
		rand.i32 :=.i32 invokestatic(MathUtils, "random",0.i32,10.i32).i32;
		ti17.i32:=.i32 _allowedNameI.i32;$1.L[ti17.i32].i32 :=.array.i32 rand.i32 +.i32 1.i32;
		_allowedNameI.i32 :=.i32 _allowedNameI.i32 +.i32 1.i32;
		goto Loop3;
		EndLoop3:
		ret.bool 1.bool;
		}
	}